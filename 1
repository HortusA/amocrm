access_token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6IjdjMmI4OGM4MDExNmRlMmZjNDMzZmJhZDAyZjk5MTllOWZkMzU5MGUxYWQ2MzUxOWIwM2NmYjRlMDM3Y2UxOGIzNjMzMDYxZGI2OWQ3ZTIwIn0.eyJhdWQiOiJmZGY4M2ZlMi05OTVlLTRhZmUtODdkMC0wNjVhZGQ5NjVmMzYiLCJqdGkiOiI3YzJiODhjODAxMTZkZTJmYzQzM2ZiYWQwMmY5OTE5ZTlmZDM1OTBlMWFkNjM1MTliMDNjZmI0ZTAzN2NlMThiMzYzMzA2MWRiNjlkN2UyMCIsImlhdCI6MTY0ODMxNzgzNCwibmJmIjoxNjQ4MzE3ODM0LCJleHAiOjE2NDg0MDQyMzQsInN1YiI6IjgwNDgyMjEiLCJhY2NvdW50X2lkIjozMDA4Mzg0Miwic2NvcGVzIjpbInB1c2hfbm90aWZpY2F0aW9ucyIsImNybSIsIm5vdGlmaWNhdGlvbnMiXX0.DwNNsutCpFTmJQ1pcCp4y_YQ6v64ERU_f_PJYhkpv_8Pzc2aV6lftOoB8hk1CfQ3ifqbwFJzYQU4atkxMdtTHC50irk6P5oJlsabA7o7akCeMrfvU31E7MWznkIYdRP6cjZiORGulwHKN95bID86mjcjAVzZQ920GQitrk-_6s_2OQz3H8kJPVAjhG0gVekgRERZYMJzeFLhM8ILzg6THimJpJTfm1mqEIF4IdHujhrOeFNEUOCGekE1owGDacoNwguyC_aEqp4rLIkHObFuyDEJaHlyVTlj2938Z01LFQ8TOpkkBnHbpc9u5iOh_qmw6B7zJfNtcBKFlcN_W8aisw'
refresh_token = 'def50200249803d0eb62cc31ff4251413d2c1b118cc91df2dfb98e581eac559ada30b9a4384d15884be78f1ac158f13609e618407a75a32016283b93f2cb8966c89f7425c6ad5c641851410cb7b4bb3ac42e7a594cd7495f2973f4326558075031e2a248e8eba8dd25395c1fa46b0e7f9c312a0841d921f71d85c385e374cd8e053835559a0ebd190e601b6c7e6fbdea736be9b40245819632d366a72609eab205ff570390f9067ed7c8b8d37f3fab690e37f3d3106b26deb5cc9cc1c48e21df967322dd87d669921e3384492a9e29bf7da4c81dc157774f28f9b71a7a6c56432e0029b8a230eacfaff1cef5df986575a8cc9676e2550c516d764c0d305197e985eea5c69b8c19239731a5a970000eebf229acb2e6ee08741cc8c633f1796072ae0567a85906600c5d2d9f44658fc6981d3c9dc20408c634df5d272f2a7005ae824b0bce9cc92f13a3ea3059e818d11e7e5f68ed27bc1167bbe8c753aa0e7a827f5bdde1f3f0f1aec17c913752995463bf2b68c38ae9ee91103b161c88c9e0303e9a2da627ec94ff7a02caa30711de8e1d216ff38d0bf86bdeff71640c9cef72e069682d45cfd54e5e0026fafa13172b969b61bc8188f9cc5fd064fffc952af195ecae6f409d53db6a6d'

import requests, os
from pathlib import Path

url_company = 'https://sadovoya.amocrm.ru/oauth2/access_token'
headers = {'Content-Type': 'application/json'}
data = {"client_id": "fdf83fe2-995e-4afe-87d0-065add965f36",
  "client_secret": "lOYf6D0rpidNMxpvADa6AKxgWKjbrDiRW6hNa2OV8tNEhUuIChNsWQEKzSprYjIj",
  "grant_type": "authorization_code",
  "code": "def502003204af2a3baf8cb4461a0d736b49246cd5f1290f7f251371bd8a4af6a00845d7e8d32c37357c7fa15dd594de7e851191d0e6c6217831cddead3e17d910fe550c62b65e48f63004617b13e110164a0ab8667b3245cfdc2433f5b482521d3ea196cd01770087fb9c44acaf90b5757ef7c5dbd531cc7e92ee9bf27cfe183ed5546a72f6341f12ea10aab419fc03678bc4d630030efd373103992caa10764e2787579677b9e0e5d343dde5bfd11879846cdd723a1fe02e58cb9b2f2fa65bdaa5a63daf62fe5c5d45c20326d0051762877858ac33de3e642e05211342f17b445ff238eee5d92212ad91a6d2b725c0611622d3695e181cebcee1e06f9492173fdeccad2a4859665218721cb610d3037ca04ef37ebac6bb574356f39aeda11b553cc4c995bcc8916c31d49a3e5deb66b3b943ec7fba7cea02cb9cc46b517fdfd41ae523675ff88d58bfac7152b8ceccdd3c67a03dae2d335393a91f986edf644a1bcbd9c4538314bd7503327d5402e84830931e105cff66fb938e167e6e2f5236cff45d62757227bf808db24a02c76fd7cb0ab7566b5c014507b8a312e5bd08da491c2c9a80ac7934ed7c0a668e521578135408a23cbf35b5",
  "redirect_uri": "https://exam.ru"}


a = requests.post(url_company, json=data, headers=headers)
print(a.status_code)

print(a.json())

import requests
from get import access_token
from pathlib import Path

url_company = 'https://sadovoya.amocrm.ru/api/v4/companies'
headers = {'Authorization': f"Bearer {access_token}"}

a = requests.get(url_company, headers=headers)
a = a.json()


a = a['_embedded']['companies']
col = 0
for i in a:
    try:
        Path(f"/home/hortus/Documents/bases/firms/{i['id']}").mkdir(parents=True, exist_ok=False)
    except OSError:
        print(f"Каталог с номером клиента - {i['id']} существует")
    else:
        col += 1
print(f'Создание каталогов завершено, Всего создано {col}')


import requests
from config import access_token
from pathlib import Path

url_company = 'https://sadovoya.amocrm.ru/api/v4/companies'
headers = {'Authorization': f"Bearer {access_token}"}


class IdCompany:
    def __init__(self, url=url_company, header=headers):
        self.url = url
        self.headers = header
        self.response = requests.get(self.url, headers=self.headers)
        self.result = None


    def amo_data(self):


    def access_data(self):
        if self.response.status_code == 200:
            self.result = self.response.json()
        else:
            print('Дотсупа нет')
        return self.result


    def show_status_cod(self):
        print(self.response.status_code)


class Dir:
    def __init__(self, idcompany, col=0):
        self.idcompany = idcompany
        self.col = col

    def show_id(self):
        data_dict = self.idcompany['_embedded']['companies']
        col = 0
        for i in data_dict:
            try:
                Path(f"/home/hortus/Documents/bases/firms/{i['id']}").mkdir(parents=True, exist_ok=False)
            except OSError:
                print(f"Каталог с номером клиента - {i['id']} существует")
            else:
                col += 1
        print(f'Создание каталогов завершено, Всего создано {col}')


a = IdCompany()
a.show_status_cod()
b = Dir(a.access_data())
b.show_id()
sqlite_select_query = """SELECT * from cms_article_content"""
cursor.execute(sqlite_select_query)
records = cursor.fetchall()
for st in records:

"""SELECT a.date, ac.content FROM cms_article_content ac
                            LEFT JOIN cms_articles a on a.article_id = ac.article_id
                            WHERE a.article_id = 7""")

# caption = (i.find('figcaption'))
                    # if caption is not None:
                    #   print(caption.text, '_______________________________________')

                        def search(self):
        self.list_all_folder = os.listdir(self.path_root)
        list_of_duplicate = []
        for checked_directory in self.list_all_folder:
            if '-' in checked_directory:
                split_directory = (checked_directory.split('-'))
                if split_directory[0] in self.list_all_folder:
                    get_files = os.listdir(f'{path_root}/{split_directory[0]}')
                    for one_directory_file in get_files:
                        if not os.path.exists(f'{path_root}/{checked_directory}/{one_directory_file}'):
                            print('Файла {g} будет скопирован')
                            shutil.copy(f'{path_root}/{split_directory[0]}/{one_directory_file}',
                                        f'{path_root}/{checked_directory}/{one_directory_file}')
                        else:
                            print(f'Файл с именем {one_directory_file} в директории {checked_directory} уже существует')

                    list_of_duplicate.append(checked_directory)
        return list_of_duplicate

f'{path_to_leads}/{one_leads[0]}/{one_file_from_leads}'










 def transferring_leads_files(self):
        for dir_in_leads in self.get_list_leads:
            if path.isdir(pathlib.Path(path_to_leads, dir_in_leads)) and \
                    len(os.listdir(pathlib.Path(path_to_leads, dir_in_leads))) != 0:
                if '-' in dir_in_leads:
                    dir_def = (dir_in_leads.split('-'))
                    if dir_def[0] in self.get_list_leads:
                        get_files = listdir(pathlib.Path(path_to_leads, '-'.join(dir_def)))
                        for file in get_files:
                            path_from_ware = (pathlib.Path(path_to_leads, '-'.join(dir_def), file))
                            path_ware = (pathlib.Path(path_to_leads, dir_def[0], file))
                            if not path.exists(path_ware):
                                if path.isfile(pathlib.Path(path_to_leads, path_from_ware)):
                                    shutil.copy(path_from_ware, path_ware)
                                else:
                                    shutil.copytree(path_from_ware, path_ware)
                                self.list_separated_leads.append(path_from_ware)
                            else:
                                self.list_of_duplicate.append(path_from_ware)
                    else:
                        if dir_def[0] not in self.get_list_leads:
                            os.makedirs(pathlib.Path(path_to_leads, dir_def[0]))
                            get_files = listdir(pathlib.Path(path_to_leads, '-'.join(dir_def)))
                            for file in get_files:
                                path_from_ware = (pathlib.Path(path_to_leads, '-'.join(dir_def), file))
                                path_ware = (pathlib.Path(path_to_leads, dir_def[0], file))
                                if not path.exists(path_ware):
                                    if path.isfile(pathlib.Path(path_to_leads, path_from_ware)):
                                        shutil.copy(path_from_ware, path_ware)
                                    else:
                                        shutil.copytree(path_from_ware, path_ware)
                                    self.list_separated_leads.append(path_from_ware)
                                else:
                                    self.list_of_duplicate.append(path_from_ware)


                                     File.write('<html>')
            File.write('<head>')
            File.write('<<title>Отчет</title>>')
            File.write('</head>')
            File.write('<body>')
            for i in name_report:
                File.write(f'<p> {i} </p>')
            File.write('</body>')
            File.write('</html>')


            name_files = time.strftime("%Y%m%d-%H%M%S")
        with open(f'{name_files}.html', 'w') as File:
            File.write('<head>')
            File.write('<<title>Отчет</title>>')
            File.write('</head>')
            File.write('<body>')
            for i in name_report:
                File.write(f'{i} ' + '\n')
            File.write('</body>')
            File.write('</html>')

            @app.route('/uploader', methods = ['GET', 'POST'])
def upload_file():
   if requests.method == 'POST':
      f = requests.files['file']
      f.save(f.filename)
      return 'file uploaded successfully'



      @app.route('/search_id', methods=['GET', "POST"])
def search_in():
    form = ElasticForm()
    if form.validate_on_submit():
        field_form = form.elastic_search.data
        resp = search_id(field_form)
        return render_template('search_id.html', form=form, search_result=resp)
    return render_template('search_id.html', form=form)


@app.route('/add_id', methods=['GET', "POST"])
def add_in():
    form = ElasticForm()

    if form.validate_on_submit():
        field_form = form.elastic_search.data
        id_dic = form.id_search.data
        resp = add_id(id_dic, field_form)
        return render_template('add_id.html', form=form, search_result=resp)
    return render_template('add_id.html', form=form)


def get_article_all():
    cursor.execute("""SELECT a.date, ac.content FROM cms_article_content ac
                            LEFT JOIN cms_articles a on a.article_id = ac.article_id
                            WHERE a.article_id""")
    return cursor.fetchall()


def execute_all():
    cursor.execute("SELECT article_id, content FROM cms_article_content")
    return cursor.fetchall()


def create_index_es():
    for cont in execute_all():
        es.index(index='my_index', id=cont[0], document={'text': (cont[1])})


def search_id(id_doc):
    resp = es.get(index='my_index', id=id_doc)
    return resp


def add_id(id_doc, text):
    resp = es.index(index='my_index', id=id_doc, document={'text': text})
    return resp